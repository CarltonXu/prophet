# 网络扫描流程和数据存储分析

## 一、整体流程概览

```
前端创建扫描任务
    ↓
后端API创建ScanTask记录 (status='pending')
    ↓
Celery异步任务启动 (scan_network_task.delay)
    ↓
NetworkController使用nmap扫描网络
    ↓
扫描结果写入CSV文件 (scan_hosts.csv)
    ↓
ScannerService读取CSV并解析
    ↓
数据保存到Host表 (hosts表)
    ↓
更新ScanTask状态 (status='completed')
    ↓
前端查看扫描结果
```

## 二、详细流程分析

### 1. 前端创建扫描任务

**文件**: `frontend/src/views/Scans.vue`

- 用户填写扫描任务信息：
  - 任务名称 (name)
  - 扫描目标 (target): IP段、IP范围或单个IP，例如 `192.168.1.0/24` 或 `192.168.1.1-100`
  - Nmap参数 (nmap_args): 默认 `-sS -O` (SYN扫描 + OS检测)

- 调用API: `scansApi.createScanTask()`

### 2. 后端API处理

**文件**: `api/scanner.py` - `create_scan_task()`

```python
# 创建ScanTask记录
scan_task = ScanTask(
    name=data['name'],
    target=data['target'],
    status='pending',  # 初始状态
    created_by=user_id,
)
db.session.add(scan_task)
db.session.commit()

# 启动Celery异步任务
scan_network_task.delay(scan_task.id, data['target'], nmap_args)
```

**ScanTask表结构** (`models/task.py`):
- `id`: 主键
- `name`: 任务名称
- `target`: 扫描目标
- `status`: 状态 (pending/running/completed/failed/cancelled)
- `progress`: 进度 (0-100)
- `result_count`: 发现的主机数量
- `current_host`: 当前正在扫描的主机IP
- `error_message`: 错误信息
- `created_by`: 创建者ID
- `created_at`: 创建时间
- `started_at`: 开始时间
- `completed_at`: 完成时间

### 3. Celery异步任务执行

**文件**: `tasks/scanner.py` - `scan_network_task()`

```python
@celery.task(bind=True, name='tasks.scan_network')
def scan_network_task(self, scan_task_id: int, host: str, nmap_args: str = None):
    service = ScannerService(scan_task_id)
    results = service.scan_and_save(host, nmap_args)
    return {'status': 'success', 'results_count': len(results)}
```

### 4. 网络扫描执行

**文件**: `prophet/scanner/network.py` - `NetworkController`

**核心方法**: `generate_report()`

1. **使用nmap扫描**:
   ```python
   self.nm = nmap.PortScanner()
   hosts = self._scan()  # 执行nmap扫描，返回发现的IP列表
   ```

2. **分析每个主机**:
   - 主机名 (hostname)
   - MAC地址 (mac)
   - 操作系统 (os): 通过 `osmatch` 获取
   - 操作系统版本 (version)
   - 厂商信息 (vendor): 通过MAC地址或nmap的vendor信息
   - SSH端口 (ssh_port): 根据操作系统类型推断
   - TCP开放端口 (tcp_ports)

3. **生成CSV文件**:
   - 文件路径: `{temp_dir}/scan_hosts.csv`
   - CSV列: `hostname, ip, username, password, ssh_port, key_path, mac, vendor, check_status, os, version, tcp_ports, do_status`

### 5. 数据保存到数据库

**文件**: `services/scanner_service.py` - `scan_and_save()`

#### 5.1 状态更新
```python
# 更新任务状态为运行中
self.scan_task.status = 'running'
self.scan_task.started_at = datetime.utcnow()
```

#### 5.2 读取CSV结果
```python
df = pd.read_csv(csv_path, keep_default_na=False)
```

#### 5.3 遍历保存每个主机
```python
for idx, row in df.iterrows():
    host_ip = row.get('ip', 'unknown')
    
    # 检查主机是否已存在
    existing_host = Host.query.filter_by(ip=host_ip, deleted_at=None).first()
    
    if existing_host:
        # 更新现有主机（只更新空字段）
        self._update_host_from_scan(existing_host, row)
    else:
        # 创建新主机
        host_obj = self._create_host_from_scan(row)
        db.session.add(host_obj)
    
    # 更新进度
    progress = int((idx + 1) / total_hosts * 100)
    self.update_progress(progress, current_host=host_ip, result_count=len(saved_hosts))
```

#### 5.4 创建主机逻辑 (`_create_host_from_scan`)
```python
Host(
    hostname=row.get('hostname', '') or None,
    ip=row.get('ip', ''),
    mac=row.get('mac', '') or None,
    vendor=row.get('vendor', '') or None,
    os_type=row.get('os', '') or None,
    os_version=row.get('version', '') or None,
    device_type='host' if row.get('os') else 'network_device',
    is_physical=True,  # 默认物理机，后续采集时可能更新
    source='scan',  # 标记来源为扫描
    source_scan_task_id=self.scan_task_id,  # 关联扫描任务
    created_by=self.scan_task.created_by,
)
```

#### 5.5 更新主机逻辑 (`_update_host_from_scan`)
- 只更新空字段，不覆盖已有数据
- 如果主机没有source，则设置为'scan'并关联扫描任务

#### 5.6 完成处理
```python
# 更新任务状态
self.scan_task.status = 'completed'
self.scan_task.completed_at = datetime.utcnow()
self.scan_task.result_count = len(saved_hosts)
self.scan_task.progress = 100
db.session.commit()
```

## 三、数据存储结构

### 1. ScanTask表 (scan_tasks)

存储扫描任务信息：

| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| name | String(255) | 任务名称 |
| target | String(255) | 扫描目标 |
| status | String(50) | 状态: pending/running/completed/failed/cancelled |
| progress | Integer | 进度 0-100 |
| result_count | Integer | 发现的主机数量 |
| current_host | String(45) | 当前扫描的主机IP |
| error_message | Text | 错误信息 |
| created_by | Integer | 创建者ID (FK -> users.id) |
| created_at | DateTime | 创建时间 |
| started_at | DateTime | 开始时间 |
| completed_at | DateTime | 完成时间 |

### 2. Host表 (hosts)

存储扫描发现的主机信息：

**关键字段**:
- `id`: 主键
- `ip`: IP地址 (唯一索引)
- `hostname`: 主机名
- `mac`: MAC地址
- `vendor`: 厂商信息
- `os_type`: 操作系统类型
- `os_version`: 操作系统版本
- `device_type`: 设备类型 (host/network_device)
- `is_physical`: 是否物理机 (默认True)
- `source`: 来源 (scan/platform/manual)
- `source_scan_task_id`: 关联的扫描任务ID (FK -> scan_tasks.id)
- `created_by`: 创建者ID
- `created_at`: 创建时间
- `updated_at`: 更新时间
- `deleted_at`: 软删除时间

**数据关系**:
- 一个ScanTask可以关联多个Host (`source_scan_task_id`)
- 一个Host只能属于一个ScanTask（通过扫描创建时）

### 3. 数据去重逻辑

- **IP唯一性**: Host表的`ip`字段有唯一约束
- **更新策略**: 
  - 如果IP已存在且未删除，则更新现有记录（只更新空字段）
  - 如果IP不存在，则创建新记录
- **错误处理**: 如果遇到唯一约束错误，会回滚并尝试更新现有记录

## 四、前端交互流程

### 1. 查看扫描任务列表

**API**: `GET /api/v1/scanner`
- 支持分页和状态筛选
- 前端每5秒轮询更新任务状态

### 2. 查看扫描结果

**API**: `GET /api/v1/scanner/<task_id>/results`
- 通过 `source_scan_task_id` 查询关联的主机
- 返回该扫描任务发现的所有主机

### 3. 添加主机到设备列表

**前端操作**: `frontend/src/views/Scans.vue`
- 单个添加: `addToHosts()` - 调用 `hostsApi.createHost()`
- 批量添加: `batchAddToHosts()` - 调用 `hostsApi.batchCreateHosts()`

**注意**: 扫描结果中的主机已经保存在Host表中，前端"添加到设备列表"操作实际上是在UI层面标记或确认这些主机。

## 五、关键设计点

### 1. 异步处理
- 使用Celery异步任务，避免阻塞API响应
- 支持长时间运行的扫描任务

### 2. 进度跟踪
- 实时更新扫描进度 (0-100%)
- 显示当前扫描的主机IP
- 更新已保存的主机数量

### 3. 错误处理
- 单个主机保存失败不影响其他主机
- 记录错误信息到ScanTask.error_message
- 任务失败时设置status='failed'

### 4. 数据一致性
- IP地址唯一性约束
- 软删除机制 (deleted_at)
- 更新现有主机时只填充空字段，不覆盖已有数据

### 5. 临时文件管理
- 使用临时目录存储CSV文件
- 扫描完成后自动清理临时文件

## 六、数据流向图

```
nmap扫描
    ↓
NetworkController.generate_report()
    ↓
生成CSV文件 (scan_hosts.csv)
    ↓
pandas读取CSV
    ↓
遍历每一行
    ↓
检查Host表是否存在 (通过IP)
    ↓
存在? → 更新现有记录 (只更新空字段)
不存在? → 创建新记录
    ↓
保存到Host表
    ↓
更新ScanTask进度和状态
```

## 七、总结

1. **扫描任务管理**: 通过ScanTask表管理扫描任务的生命周期
2. **数据存储**: 扫描结果直接保存到Host表，通过`source_scan_task_id`关联
3. **去重机制**: 基于IP地址的唯一性，自动处理重复扫描的情况
4. **异步处理**: 使用Celery实现异步扫描，不阻塞用户操作
5. **进度跟踪**: 实时更新扫描进度和状态，提供良好的用户体验

